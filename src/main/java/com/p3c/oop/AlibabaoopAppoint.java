package com.p3c.oop;

/**
 * OOP规约
 *
 * <p>1,避免通过一个类的对象引用访问此类的静态变量或者静态方法，造成无谓增加编译器解析成本，直接用类名来访问即可。
 *
 * <p>2，所有的覆写方法，必须加@Override注解
 *
 * <p>3,相同的参数类型，相同的业务含义，才可以使用java的可变参数，避免使用Object
 *
 * <p>4,对外部正在调用或者二方库依赖的接口，不允许修改方法签名，以避免对接口调用方产生影响，叵接口过时，必须加@Deprecated注解， 并清晰的说明采用新接口或者新服务是什么。
 *
 * <p>5，不能使用过时的类或方法。
 *
 * <p>6，Object的equals方法容易抛空指针异常，应使用常量或者确定的值的对象调用equals
 *
 * <p>7,所有相同炻的包装类对象之值的比较，全部使用equals方法。
 *
 * <p>8，关于基本数据类型与包装数据类型的使用标准如下：
 *
 * <p>8.1）强制所有的POJO类属性必须使用包装数据类型。
 *
 * <p>8.2）RPC方法的返回值和参数必须命名用包装数据精英。
 *
 * <p>8.3）所有的局部变量使用基本数据类型
 *
 * <p>9，在定义DO/DTO/VO等POJO类时，不要设定任何属性的默认值
 *
 * <p>10,当序列化类新增加属性时，请不要修改servialVersionUID字段，以避免反序列化失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID
 *
 * <p>11,构造方法里禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中
 *
 * <p>12，POJO类必须写toString方法，在使用IDE中的工具source>generate toString时，如果继承了POJO类，注意在前面加一个super.toString。
 *
 * <p>13,当使用索引访问String的Split方法得到数组时，需在最后一个分隔符后做有无内容的检查，否则会有抛IndexOutOfBoundsExcepton的风险.
 *
 * <p>14,当一个类有多个构造方法，或者多个同名方法时，这些方法应该按顺序放置在一起，便于阅读，此条规优先于第15条规则
 *
 * <p>15，类内方法定义顺序是:公有方法或者保护方法 》 私有方法 》 getter 》 setter方法
 *
 * <p>16，在setter方法中参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter方法中，不要增加业务逻辑，否否会增加排查问题的难度.
 *
 * <p>17,在循环体内，字符串的连接方式使用StringBuilder的append方法进行扩展。
 *
 * <p>18，final可以声明类，成员变量、方法及本地变量，下列情况使用final关键字：
 *
 * <p>18.1)不允许被继承的类，如：String类。
 *
 * <p>18.2)不允许修改引用的域对象， 如：POJO类的域变量。
 *
 * <p>18.3）不允许修改被重写的方法，如POJO类的setter方法
 *
 * <p>18.4)不允许运行过程中重新赋值的局部变量。
 *
 * <p>18.5）避免上下文重复使用一个变量，使用final描述可以强制定义一个新变量，方便更好的进行重构。
 *
 * <p>19，慎用Object的clone方法来拷贝对象.
 *
 * <p>20,类成员与方法访问控制从严
 *
 * 20.1)如果不允许直接通过new来创建对象，那么构造方法必须限制为private。
 *
 * 20.2)工具类不允许有public或者default构造方法.
 *
 * 20.3)类非static成员变量并且与子类共享，必须限制为protected.
 *
 * 20.4)类非static成员变量，并且仅在本实例中，必须限制为private
 *
 * 20.5)类static成员变量如果仅在本类使用,必须限制为private.
 *
 * 20.6)若是static成员变量，必须考滤是否为final
 *
 * 20.7)类成员方法只供类内部调用，必须限制为private.
 *
 * 20.8)类成员方法只对继承类公开，限制制为protected.
 */
public class AlibabaoopAppoint {}
